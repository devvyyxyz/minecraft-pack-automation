name: Reusable Pack Update Workflow

on:
  workflow_call:
    inputs:
      modrinth_project_id:
        description: 'Modrinth project ID (slug or ID)'
        required: true
        type: string
      pack_name:
        description: 'Resource pack name used for zip file name'
        required: false
        type: string
        default: 'Resource Pack'
    secrets:
      MODRINTH_TOKEN:
        description: 'Modrinth API token'
        required: true

jobs:
  update-pack:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout pack repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Resolve latest and previous releases
        id: resolve
        run: |
          python3 - << 'PY'
          import json
          import urllib.request

          MANIFEST_URL = "https://piston-meta.mojang.com/mc/game/version_manifest_v2.json"

          def fetch_json(url: str) -> dict:
              with urllib.request.urlopen(url) as resp:
                  return json.load(resp)

          manifest = fetch_json(MANIFEST_URL)
          versions = manifest.get("versions", [])
          release_indices = [i for i, v in enumerate(versions) if v.get("type") == "release"]
          if not release_indices:
              raise SystemExit("No release versions found in manifest")

          latest_id = manifest.get("latest", {}).get("release") or versions[release_indices[0]].get("id")
          latest_idx = next((i for i, v in enumerate(versions) if v.get("id") == latest_id), release_indices[0])
          previous_idx = next((i for i in release_indices if i > latest_idx), None)

          targets = [versions[latest_idx]]
          if previous_idx is not None:
              targets.append(versions[previous_idx])

          def resolve_pack_format(entry: dict) -> tuple[str, int]:
              version_id = entry.get("id")
              version_data = fetch_json(entry["url"])
              pack_version = version_data.get("packVersion") or version_data.get("pack_version") or {}
              if isinstance(pack_version, dict):
                  pack_format = pack_version.get("resource") or pack_version.get("resourcePack") or pack_version.get("resource_pack")
              else:
                  pack_format = pack_version
              if pack_format is None:
                  raise SystemExit(f"Missing pack format for {version_id}")
              return version_id, int(pack_format)

          grouped: dict[int, set[str]] = {}
          for entry in targets:
              version_id, pack_format = resolve_pack_format(entry)
              grouped.setdefault(pack_format, set()).add(version_id)

          groups = [
              {"pack_format": pack_format, "versions": sorted(list(versions), reverse=True)}
              for pack_format, versions in sorted(grouped.items(), key=lambda item: -item[0])
          ]

          output = {"groups": groups}
          with open("versions_to_update.json", "w", encoding="utf-8") as f:
              json.dump(output, f, indent=2)
          print(json.dumps(output, indent=2))
          PY
          echo "versions_json<<EOF" >> $GITHUB_OUTPUT
          cat versions_to_update.json >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Extract pack format groups
        id: extract
        run: |
          python3 - << 'PY'
          import json
          with open('versions_to_update.json') as f:
              data = json.load(f)
          for i, group in enumerate(data.get('groups', [])):
              versions = ','.join(group['versions'])
              print(f'GROUP_{i}_VERSIONS={versions}')
              print(f'GROUP_{i}_PACK_FORMAT={group["pack_format"]}')
          print(f'TOTAL_GROUPS={len(data.get("groups", []))}')
          PY >> $GITHUB_OUTPUT

      - name: Read VERSION file
        id: version
        run: echo "PACK_VERSION=$(cat VERSION)" >> $GITHUB_OUTPUT

      - name: Update pack files
        run: python3 scripts/update_pack.py

      - name: Create resource pack zip
        run: |
          mkdir -p build
          zip -r "build/${{ inputs.pack_name }}.zip" pack.mcmeta assets/ -x "*.DS_Store"

      - name: Upload to Modrinth (all groups)
        env:
          MODRINTH_TOKEN: ${{ secrets.MODRINTH_TOKEN }}
          PACK_VERSION: ${{ steps.version.outputs.PACK_VERSION }}
        run: |
          groups_count=${{ steps.extract.outputs.TOTAL_GROUPS }}
          if [ "$groups_count" -eq 0 ]; then
            echo "No pack-format groups resolved; skipping upload."
            exit 0
          fi
          for i in $(seq 0 $((groups_count - 1))); do
            eval "versions=\$GROUP_${i}_VERSIONS"
            eval "pack_format=\$GROUP_${i}_PACK_FORMAT"

            version_number="${PACK_VERSION}-pf${pack_format}"

            echo "Uploading version $version_number for pack format $pack_format"
            python3 scripts/upload_modrinth.py \
              "build/${{ inputs.pack_name }}.zip" \
              "${{ inputs.modrinth_project_id }}" \
              "$versions" \
              "$version_number" \
              "$MODRINTH_TOKEN"
          done
