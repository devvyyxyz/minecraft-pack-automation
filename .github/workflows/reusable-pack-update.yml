name: Reusable Pack Update Workflow

on:
  workflow_call:
    inputs:
      modrinth_project_id:
        description: 'Modrinth project ID (slug or ID)'
        required: true
        type: string
      pack_name:
        description: 'Resource pack name used for zip file name'
        required: false
        type: string
        default: 'Resource Pack'
    secrets:
      MODRINTH_TOKEN:
        description: 'Modrinth API token'
        required: true

jobs:
  update-pack:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout pack repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Resolve versions to update
        id: resolve
        run: |
          if [ -f scripts/resolve_versions.py ]; then
            echo "Using repo-provided scripts/resolve_versions.py"
            python3 scripts/resolve_versions.py "${{ inputs.modrinth_project_id }}" > versions_to_update.json
          else
            echo "scripts/resolve_versions.py not found; falling back to built-in resolver (latest + previous release)."
            python3 - <<'PYSCRIPT'
            import json
            import urllib.request

            MANIFEST_URL = "https://piston-meta.mojang.com/mc/game/version_manifest_v2.json"
            MISODE_PACKS_URL = "https://raw.githubusercontent.com/misode/mcmeta/summary/versions/data.json"

            def fetch_json(url: str) -> dict:
                with urllib.request.urlopen(url) as resp:
                    return json.load(resp)

            def fetch_pack_format_from_misode(version_id: str) -> int | None:
                try:
                    data = fetch_json(MISODE_PACKS_URL)
                except Exception:
                    return None
                version_entry = data.get("versions", {}).get(version_id)
                if not version_entry:
                    return None
                pack_format = version_entry.get("resource")
                return int(pack_format) if pack_format is not None else None

            manifest = fetch_json(MANIFEST_URL)
            versions = manifest.get("versions", [])
            release_indices = [i for i, v in enumerate(versions) if v.get("type") == "release"]
            if not release_indices:
                raise SystemExit("No release versions found in manifest")

            latest_id = manifest.get("latest", {}).get("release") or versions[release_indices[0]].get("id")
            latest_idx = next((i for i, v in enumerate(versions) if v.get("id") == latest_id), release_indices[0])
            previous_idx = next((i for i in release_indices if i > latest_idx), None)

            targets = [versions[latest_idx]]
            if previous_idx is not None:
                targets.append(versions[previous_idx])

            def resolve_pack_format(entry: dict) -> tuple[str, int]:
                version_id = entry.get("id")
                version_data = fetch_json(entry["url"])
                pack_version = (
                    version_data.get("packVersion")
                    or version_data.get("pack_version")
                    or version_data.get("pack")
                    or {}
                )

                def extract_pack_format(pv):
                    if isinstance(pv, dict):
                        return (
                            pv.get("resource")
                            or pv.get("resourcePack")
                            or pv.get("resource_pack")
                            or pv.get("resource_pack_version")
                            or pv.get("pack_format")
                        )
                    return pv

                pack_format = extract_pack_format(pack_version)

                if pack_format is None:
                    pack_format = version_data.get("resourcePackVersion") or version_data.get("resource_pack_version")

                if pack_format is None:
                    pack_format = fetch_pack_format_from_misode(version_id)

                if pack_format is None:
                    raise SystemExit(f"Missing pack format for {version_id}")

                return version_id, int(pack_format)

            grouped: dict[int, set[str]] = {}
            for entry in targets:
                version_id, pack_format = resolve_pack_format(entry)
                grouped.setdefault(pack_format, set()).add(version_id)

            groups = [
                {"pack_format": pack_format, "versions": sorted(list(versions), reverse=True)}
                for pack_format, versions in sorted(grouped.items(), key=lambda item: -item[0])
            ]

            output = {"groups": groups}
            with open("versions_to_update.json", "w", encoding="utf-8") as f:
                json.dump(output, f, indent=2)
            print(json.dumps(output, indent=2))
            PYSCRIPT
          fi

          echo "versions_json<<EOF" >> $GITHUB_OUTPUT
          cat versions_to_update.json >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Extract pack format groups
        id: extract
        run: |
          python3 - << 'PY'
          import json
          with open('versions_to_update.json') as f:
              data = json.load(f)
          for i, group in enumerate(data.get('groups', [])):
              versions = ','.join(group['versions'])
              print(f'GROUP_{i}_VERSIONS={versions}')
              print(f'GROUP_{i}_PACK_FORMAT={group["pack_format"]}')
          print(f'TOTAL_GROUPS={len(data.get("groups", []))}')
          PY >> $GITHUB_OUTPUT

      - name: Read VERSION file
        id: version
        run: echo "PACK_VERSION=$(cat VERSION)" >> $GITHUB_OUTPUT

      - name: Update pack files
        run: python3 scripts/update_pack.py

      - name: Create resource pack zip
        run: |
          mkdir -p build
          zip -r "build/${{ inputs.pack_name }}.zip" pack.mcmeta pack.png assets/ -x "*.DS_Store"

      - name: Upload to Modrinth (all groups)
        env:
          MODRINTH_TOKEN: ${{ secrets.MODRINTH_TOKEN }}
          PACK_VERSION: ${{ steps.version.outputs.PACK_VERSION }}
        run: |
          groups_count=${{ steps.extract.outputs.TOTAL_GROUPS }}
          if [ "$groups_count" -eq 0 ]; then
            echo "No pack-format groups resolved; skipping upload."
            exit 0
          fi
          for i in $(seq 0 $((groups_count - 1))); do
            eval "versions=\$GROUP_${i}_VERSIONS"
            eval "pack_format=\$GROUP_${i}_PACK_FORMAT"

            version_number="${PACK_VERSION}-pf${pack_format}"

            echo "Uploading version $version_number for pack format $pack_format"
            python3 scripts/upload_modrinth.py \
              "build/${{ inputs.pack_name }}.zip" \
              "${{ inputs.modrinth_project_id }}" \
              "$versions" \
              "$version_number" \
              "$MODRINTH_TOKEN"
          done
